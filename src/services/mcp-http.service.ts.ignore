import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport, StreamableHTTPServerTransportOptions } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { createRaindropServer } from './mcp.service.js';
import { randomUUID } from 'crypto';

export class MCPHttpService {
  private mcpServer: McpServer | null = null;
  private httpTransport: StreamableHTTPServerTransport | null = null;
  private port: number;
  private stateful: boolean;
  private debug: boolean;

  constructor(options: { 
    port?: number; 
    stateful?: boolean;
    debug?: boolean;
  } = {}) {
    this.port = options.port ?? 3000;
    this.stateful = options.stateful ?? true;
    this.debug = options.debug ?? false;
  }

  public async start(): Promise<void> {
    try {
      // Create the MCP server for Raindrop
      const { server, cleanup } = await createRaindropServer();
      this.mcpServer = server;
      
      // Create HTTP transport
      this.httpTransport = new StreamableHTTPServerTransport({
        port: this.port,
        corsOrigins: ['*'], // Allow all origins in development
        debug: this.debug, // Enable debug mode for easier troubleshooting
        
        // Session ID generator based on stateful mode
        sessionIdGenerator: this.stateful 
          ? () => randomUUID() 
          : () => undefined,
      });

      // Connect server to transport
      await this.mcpServer.connect(this.httpTransport);
      
      const mode = this.stateful ? 'stateful' : 'stateless';
      process.stdout.write(`MCP HTTP Server running in ${mode} mode on port ${this.port}\n`);
      process.stdout.write(`You can test the server by navigating to http://localhost:${this.port}/mcp in your browser\n`);
      process.stdout.write(`To use with the Inspector, set INSPECTOR_URL=http://localhost:${this.port}/mcp\n`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      process.stderr.write(`Failed to start MCP HTTP server: ${errorMessage}\n`);
      throw error;
    }
  }

  public async stop(): Promise<void> {
    try {
      if (this.mcpServer) {
        // Disconnect and clean up server
        await this.mcpServer.close();
        this.mcpServer = null;
      }

      if (this.httpTransport) {
        // Close HTTP server
        await this.httpTransport.close();
        this.httpTransport = null;
      }

      process.stdout.write("MCP HTTP Server stopped\n");
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      process.stderr.write(`Error stopping MCP HTTP server: ${errorMessage}\n`);
    }
  }
}

// Export a singleton instance for convenience
export const mcpHttpService = new MCPHttpService({
  // Allow port to be configured via environment variable
  port: process.env.MCP_HTTP_PORT ? parseInt(process.env.MCP_HTTP_PORT, 10) : 3000,
  // Allow configuring stateful/stateless mode via environment variable
  stateful: process.env.MCP_STATEFUL !== 'false',
  // Enable debug mode via environment variable
  debug: process.env.MCP_DEBUG === 'true',
});
